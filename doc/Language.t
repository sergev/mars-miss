
+   %% = = = = = = = = = = = = = = = = = = = = = = = = = %%
+   %%                                                   %%
+   %%   MULTIPURPOSE INTERACTIVE TIME SHARING SYSTEM    %%
+   %%                                                   %%
+   %%       MultiAccess Relational data System          %%
+   %%                  Язык запросов                    %%
+   %%                                                   %%
+   %% = = = = = = = = = = = = = = = = = = = = = = = = = %%



  1. Основные понятия
      1.1 Реляционная модель данных
      1.2 Типы хранимых данных

  2. Выборка данных
      2.1 Проекции
      2.2 Табличные выражения
      2.3 Селекция       (SELECT)
      2.4 Упорядочивание (ORDER)
      2.5 Об'единение    (UNION)
      2.6 Группирование  (GROUP)
      2.7 Соединение     (JOIN )

  3. Управление структурой базы данных
      3.1 Создание и уничтожение таблиц
      3.2 Индексы и их использование
      3.3 Создание и уничтожение индексов

  4. Модификация данных
      4.1 Добавление  записей (INSERT)
      4.2 Удаление    записей (DELETE)
      4.3 Модификация записей (UPDATE)

  5. Параметризация запросов

  6. Транзакции и синхронизации
      6.1 Понятие транзакции. Блокировки
      6.2 Окончание транзакции (COMMIT)
      6.3 Откат транзакции     (ROLLBACK)
      6.4 Блокировка таблиц    (LOCK)

  7. Скалярные выражения
      7.1 Скалярные операнды
      7.2 Скалярные операции
      7.3 Встроенные скалярные функции
      7.4 Условные выражения
      7.5 Подзапросы

  8. Авторизация доступа
      8.1 Принципы идентификации
      8.2 Права пользователя
      8.3 Доступ к таблицам

  9. Специальные запросы

 10. Формальное описание языка запросов

\
+                     1. Основные понятия

  1.1 Реляционная модель данных

     Реляционная  модель  данных  основана  на  представлении
 данных в  виде  2-х  мерных  таблиц,  имеющих  фиксированное
 количество поименованных  столбцов, содержащих данные одного
 типа. Столбцы  называют также  "атрибутами". Число  строк  в
 таблицах  не  фиксировано  и  изменяется  при  добавлении  и
 удалении данных.  Строки  (называемые  ниже  "записями")  не
 упорядочены в  таблицах, поэтому  "таблица"  на  самом  деле
 является  просто  "множеством"  записей.  Таким  образом  не
 существует  какого-либо   "номера  записи",   которым  может
 оперировать пользователь.


  1.2  Типы хранимых данных

     Хранимые в базах данные могут быть следующих типов:

 SHORT    - целое 16-битовое число со знаком: -32768..+32767;
 LONG     - целое 32-битовое число со знаком: -2E+09..-2E+09;
 FLOAT    - плавающее, 7 десятичных знаков мантиссы, диапазон
            показателя -74..+74
 CHAR(n)  - текстовое фиксированной длины "n" (n<200);
 VARCHAR(n)-текстовое переменной длины, от 0 до "n" (n<200);

 Замечание: при  выполнении арифметических операций с данными
            разного  типа  операнды  приводядтся к "старшему"
            типу, старшинство типов (по возрастанию):
            SHORT, LONG, FLOAT

 \
     Каждая   таблица   имеет  имя  и  владельца.  Владельцем
 является  пользователь  базы  данных, создавший эту таблицу.
 При   использовании   в   запросах   "чужих"   таблиц,  т.е.
 принадлежащих  другим  пользователям,  перед  именем таблицы
 пишется имя владельца, отделенное от имени таблицы точкой.
     Имена  таблиц, принадлежащих разным пользователям, могут
 совпадать.

     Дальнейшее изложение будет основано на примере следующих
 таблиц:

                          SYS.сотрудники
    +-------------+------------+--------------+----------+
    | фамилия     |   отдел    |   рождение   | зарплата |
    +-------------+------------+--------------+----------+
    | Иванов      |    3       |    1972      |   90.00  |
    | Абрамович   |    1       |    1953      |  200.00  |
    | Петров      |    1       |    1950      |  195.00  |
    | Рабинович   |    2       |    1946      |  215.00  |
    | Сидоров     |    2       |    1965      |  120.00  |
    | Розенкранц  |    3       |    1960      |  125.00  |
    | Васильев    |    3       |    1961      |  140.00  |
    | Шапиро      |    1       |    1917      |  410.00  |
    | Гаврилов    |    2       |    1959      |  200.00  |
    | Хайкин      |    2       |    1952      |  300.00  |
    | Семенов     |    1       |    1959      |  130.00  |
    | Гурвич      |    3       |    1965      |  125.00  |
    | Владимиров  |    2       |    1949      |  210.00  |
    | Петренко    |    1       |    1937      |  500.00  |
    | Гвоздев     |    1       |    1920      |  100.00  |
    | Вайлдбрумия |    3       |    1951      |   90.00  |
    | Горгонер    |    2       |    1936      |  250.00  |
    | Банных      |    3       |    1954      |  210.00  |
    | Чмухин      |    2       |    1920      |  100.00  |
    | Помидорских |    1       |    1960      |  185.00  |
    | Лигерос     |    1       |    1965      |   40.00  |
    +-------------+------------+--------------+----------+

                          SYS.отделы
              +---------+------------+---------+
              |  отдел  | начальник  | бюджет  |
              +---------+------------+---------+
              |     1   | Петренко   | 1500.00 |
              |     2   | Хайкин     | 1500.00 |
              |     3   | Банных     | 1000.00 |
              +---------+------------+---------+
\
+                      2. Выборка данных


     2.1 Проекции.

     При  выборке  данных из  базы, как правило, не требуются
 все  столбцы  используемой  таблицы,  а только часть их. Для
 этого  используется  "проекция",  т.е.  определение столбцов
 выходной таблицы.
     Проекция задается фразой FOR:

 SELECT SYS.отделы FOR начальник,отдел

     Результирующая  таблица  будет  иметь  только  указанные
 столбцы, причем расположенные в указанном порядке:

                   +------------+---------+
                   | начальник  | отдел   |
                   +------------+---------+
                   | Петренко   |   1     |
                   | Хайкин     |   2     |
                   | Банных     |   3     |
                   +------------+---------+

     Результирующая   таблица  может  иметь  имена  столбцов,
 отличные  от  имен  столбцов  исходной  таблицы,  для  этого
 желаемое  имя  столбца  пишется  перед определением столбца,
 через двоеточие:

 SELECT отделы FOR шеф:начальник,код:отдел

                   +------------+---------+
                   |     шеф    |  код    |
                   +------------+---------+
                   | Петренко   |   1     |
                   | Хайкин     |   2     |
                   | Банных     |   3     |
                   +------------+---------+

     Выходная  таблица  может  содержать  не  только  данные,
 записанные  в  исходных таблицах, но и результаты вычислений
 над  ними.  Вычисления задаются выражениями, в которых могут
 участвовать  все  атрибуты  записи, а также константы и т.п.
 (подробнее выражения будут описаны ниже)

 SELECT SYS.отделы FOR шеф:начальник, новый:отдел+20,
                       смесь:отдел*1000-бюджет

              +------------+---------+---------+
              |     шеф    | новый   | смесь   |
              +------------+---------+---------+
              | Петренко   |   21    |  -500   |
              | Хайкин     |   22    |   500   |
              | Банных     |   23    |  2000   |
              +------------+---------+---------+

     Таким   образом,   задание   столбцов  выходной  таблицы
 (проекция), в общем виде выглядит так:
     ... FOR имя_столбца:выражение,имя_столбца:выражение,...
 если "выражение" состоит  только  из  имени столбца исходной
 таблицы  (или подзапроса, см. ниже), то часть "имя_столбца:"
 можно опустить.

     В  выражении можно явно указывать, из какой таблицы взят
 данный атрибут. Такой уточняющий "квалификатор" записывается
 перед именем атрибута, отделяясь от него точкой:

 SELECT SYS.отделы FOR шеф:отделы.начальник, новый: отдел+20,
                       смесь: отделы.отдел*1000-отделы.бюджет

     Можно    также    присваивать   для   удобства   "метки"
 используемым таблицам, назначая новые ссылочные имена. Метка
 записывается   перед   именем   таблицы,  отделяясь  от  нее
 двоеточием:

 SELECT X:SYS.отделы FOR шеф: X.начальник, новый: отдел+20,
                       смесь: X.отдел*1000 - X.бюджет

     Заметим,  что при использовании в качестве квалификатора
 имени таблицы, а не метки, указывается только собственно имя
 таблицы, без имени владельца таблицы.


 \ 2.2 Табличные выражения

     Получающиеся  в результате выборки данных результирующие
 таблицы   могут  быть  использованы  в  об'емлющей  операции
 выборки вместо реальной таблицы, хранимой в базе данных.

     SELECT
        (SELECT SYS.отделы FOR шеф:начальник,код:отдел+100)
     FOR командир:шеф,шифр:код+1000

                   +------------+---------+
                   | командир   | шифр    |
                   +------------+---------+
                   | Петренко   |   1101  |
                   | Хайкин     |   1102  |
                   | Банных     |   1103  |
                   +------------+---------+


     Табличным выражением является либо имя реальной таблицы,
 хранимой  в  базе  данных,  либо  операция выборки данных. В
 операциях  выборки  данных используются табличные выражения,
 таким образом возможны вложенные операции выборки данных.
     При   использовании   в   выражении   подвыражения,   не
 являющегося   именем  таблицы,  оно  заключается  в  круглые
 скобки, перед которыми может быть записана метка, отделенная
 двоеточием:

   SELECT
     тест:(SELECT SYS.отделы FOR шеф:начальник,код:отдел+100)
   FOR командир:тест.шеф,шифр:код+1000

     В этом случае можно опустить фразу  "FOR",  определяющую
 проекции:    будут    взяты    все   столбцы   используемого
 подвыражения:

     ORDER
       (SELECT SYS.отделы FOR шеф:начальник,код:отдел+100)
     BY шеф

 \ 2.3  Селекция (SELECT)

     При  выборке  данных  обычно  требуются  не  все  записи
 таблицы,   а   только   те  из  них,  которые  удовлетворяют
 определенным   критериям.   Отбор  записей,  удовлетворяющих
 условию   (предикату)   называется   "селекцией".   Операция
 селекции  задается  ключевым  словом SELECT и включает фразу
 "WHERE", содержащую предикат поиска:

   SELECT SYS.сотрудники WHERE отдел=3 FOR фамилия,зарплата

                  +-------------+----------+
                  | фамилия     | зарплата |
                  +-------------+----------+
                  | Иванов      |   90.00  |
                  | Розенкранц  |  125.00  |
                  | Васильев    |  140.00  |
                  | Гурвич      |  125.00  |
                  | Вайлдбрумия |   90.00  |
                  | Банных      |  210.00  |
                  +-------------+----------+


   SELECT SYS.сотрудники WHERE отдел=10 FOR фамилия,зарплата

                  +-------------+----------+
                  | фамилия     | зарплата |
                  +-------------+----------+  (пустая
                  +-------------+----------+   таблица)


   SELECT SYS.сотрудники WHERE
        (отдел>1 AND зарплата<100) OR
        (отдел=1 AND NOT рождение>=1930)
                         FOR фамилия,отдел,рождение,зарплата

    +-------------+------------+--------------+----------+
    | фамилия     |   отдел    |   рождение   | зарплата |
    +-------------+------------+--------------+----------+
    | Иванов      |    3       |    1972      |   90.00  |
    | Шапиро      |    1       |    1917      |  410.00  |
    | Гвоздев     |    1       |    1920      |  100.00  |
    | Вайлдбрумия |    3       |    1951      |   90.00  |
    +-------------+------------+--------------+----------+

     Фраза WHERE может отсутствовать, при этом выбираются все
 строки таблицы.



 \ 2.4  Упорядочивание (ORDER)

     Как  уже  было  указано, таблицы базы данных являются на
 самом  деле множествами, т.е. записи в них не упорядочены ни
 по  значениям  каких-либо  столбцов, ни по времени занесения
 записи  в  таблицу.  В  то же время при использовании данных
 часто  бывает  нужно  получать  записи  в некотором порядке,
 определяемом значениями атрибутов записи.
     Операция упорядочивания задается ключевым словом "ORDER"
 с  фразой  "BY",  определяющей  имена  столбцов,  по которым
 производится    упорядочивание:

     ORDER SYS.сотрудники BY зарплата FOR фамилия,зарплата

                  +-------------+----------+
                  | фамилия     | зарплата |
                  +-------------+----------+
                  | Лигерос     |   40.00  |
                  | Иванов      |   90.00  |
                  | Вайлдбрумия |   90.00  |
                  | Гвоздев     |  100.00  |
                  | Чмухин      |  100.00  |
                  | Сидоров     |  120.00  |
                  | Розенкранц  |  125.00  |
                  | Гурвич      |  125.00  |
                  | Семенов     |  130.00  |
                  | Васильев    |  140.00  |
                  | Помидорских |  185.00  |
                  | Петров      |  195.00  |
                  | Гаврилов    |  200.00  |
                  | Абрамович   |  200.00  |
                  | Владимиров  |  210.00  |
                  | Банных      |  210.00  |
                  | Рабинович   |  215.00  |
                  | Горгонер    |  250.00  |
                  | Хайкин      |  300.00  |
                  | Шапиро      |  410.00  |
                  | Петренко    |  500.00  |
                  +-------------+----------+

     При    задании    нескольких    столбцов    производится
 упорядочивание по  указанному  первым,  а  среди  записей  с
 одинаковым значением этого атрибута - по указанному вторым и
 т.д.

 ORDER (SELECT SYS.сотрудники
        WHERE зарплата>195 AND зарплата<215
        FOR зарплата,фамилия,рождение)
 BY зарплата , рождение
 FOR фамилия, зарплата, рождение

             +-------------+----------+----------+
             | фамилия     | зарплата | рождение |
             +-------------+----------+----------+
             | Абрамович   |  200.00  |   1953   |
             | Гаврилов    |  200.00  |   1959   |
             | Владимиров  |  210.00  |   1949   |
             | Банных      |  210.00  |   1954   |
             +-------------+----------+----------+

     Если  необходимо  упорядочивание  не в возрастающем, а в
 убывающем порядке, то после имени столбца необходимо указать
 ключевое  слово  "DESC",  а  для  явного  задания порядка по
 возрастанию можно указать "ASC".

 ORDER (SELECT SYS.сотрудники
        WHERE зарплата>195 AND зарплата<215
        FOR зарплата,фамилия,рождение)
 BY зарплата DESC, рождение ASC
 FOR фамилия, зарплата, рождение

             +-------------+----------+----------+
             | фамилия     | зарплата | рождение |
             +-------------+----------+----------+
             | Владимиров  |  210.00  |   1949   |
             | Банных      |  210.00  |   1954   |
             | Абрамович   |  200.00  |   1953   |
             | Гаврилов    |  200.00  |   1959   |
             +-------------+----------+----------+

     Ввиду  того,  что другие операции выборки не гарантируют
 сохранения   упорядочивания,  "ORDER"-операция  имеет  смысл
 только  на  самом "верхнем" уровне табличных выражений (т.е.
 использование ее в подвыражении бессмысленно).


 \ 2.5 Об'единение (UNION)

     При  наличии  нескольких таблиц с одинаковым количеством
 столбцов  и одинаковыми именами столбцов их можно "склеить",
 то  есть  об'единить  в  одну таблицу записи из этих таблиц.
 Типы   данных   в   соответствующих   столбцах  должны  быть
 одинаковыми или совместимыми (см. ниже).
     Операция  об'единения  задается ключевым словом "UNION":

     UNION
      (SELECT SYS.сотрудники WHERE отдел=3
             FOR фамилия,          причина:'из 3-го отдела'),
      (SELECT SYS.отделы
             FOR фамилия:начальник,причина:'начальник')

                  +-------------+----------------+
                  | фамилия     | причина        |
                  +-------------+----------------+
                  | Иванов      | из 3-го отдела |
                  | Розенкранц  | из 3-го отдела |
                  | Васильев    | из 3-го отдела |
                  | Гурвич      | из 3-го отдела |
                  | Вайлдбрумия | из 3-го отдела |
                  | Банных      | из 3-го отдела |
                  | Петренко    | начальник      |
                  | Хайкин      | начальник      |
                  | Банных      | начальник      |
                  +-------------+----------------|

     Если   в  таблицах  встречаются  одинаковые  записи,  то
 дубликаты не удаляются.


 \  2.6 Группирование (GROUP)

     Часто встречающейся на практике задачей является подсчет
 статистических  характеристик  по  группам данных. Для этого
 используется    операция    группирования.    Она   собирает
 (группирует)   записи,   содержащие  одинаковые  значения  в
 указанных  столбцах,  создавая для каждой группы одну запись
 результирующей таблицы.
     Операция  группирования задается ключевым словом "GROUP"
 и   фразой  "BY",  содержащей  имена  столбцов,  по  которым
 производится группирование.
     Выражения,  определяющие проекции во фразе "FOR", должны
 принимать константные значения для всех записей группы, т.е.
 в  них  могут  быть  использованы имена только тех столбцов,
 по   которым   производится   группирование,  а  также  т.н.
 "функции  редукции",  аргументами  которых  могут быть любые
 выражения. Аргументы функции редукции вычисляются для каждой
 записи,  входящей   в  группу,  а  функция  генерирует  одно
 значение для  всей  группы,  являющееся  минимумом  (функция
 "MIN", максимумом ("MAX"), средним значением ("AVG"), суммой
 ("SUM") значений, вычисленных для записей группы. Существует
 также функция  редукции "счетчик",  не  имеющая  параметров,
 которая генерирует  число -  количество  записей  в  группе;
 обращение к этой функции записывается как "COUNT(*)".

   GROUP SYS.сотрудники BY отдел FOR отдел,штат:COUNT(*)

                       +-------+-------+
                       | отдел | штат  |
                       +-------+-------+
                       |   1   |  8    |
                       |   2   |  7    |
                       |   3   |  6    |
                       +-------+-------+

   GROUP SYS.сотрудники BY отдел
            FOR отдел,бюджет:SUM(зарплата),
                возраст:AVG(1989-рождение),
                максимум:MAX(зарплата)

           +-------+---------+---------+----------+
           | отдел | бюджет  | возраст | максимум |
           +-------+---------+---------+----------+
           |   1   | 1760.00 |  43     |  500.00  |
           |   2   | 1395.00 |  42     |  300.00  |
           |   3   |  780.00 |  28     |  210.00  |
           +-------+---------+---------+----------+


 \ 2.7 Соединение (JOIN)

     Основным   преимуществом   реляционной  модели  является
 возможность  сочетания  любых  данных  из любых таблиц, т.е.
 связи   между   данными   определены   только   для  данных,
 относящихся  к одной таблице, а связи между таблицами задает
 сам  пользователь. Такое связывание осуществляется операцией
 "соединения".
     Операция соединения  задается ключевым  словом "JOIN"  и
 фразой "WHERE",  задающей  "предикат  слияния".  Выполняется
 операция  следующим   образом:  считывается   запись  первой
 таблицы,  затем   прочитывается  вторая  таблица;  если  для
 считаной записи  условие слияния  выполняется, то фомируется
 результирующая запись из полей обеих записей и чтение второй
 таблицы   продолжается;   после   прочтения   всей   таблицы
 считывается  следующая   запись  первой   таблицы  и   вновь
 просматривается  вся  вторая  таблица.  Аналогично  работает
 слияние  трех  и  более таблиц. Фраза FOR, задающая проекции
 необходима.
     В  выражениях,  определяющих проекции и предикат слияния
 все   имена   столбцов   должны  иметь  квалификатор  -  имя
 соответствующей   таблицы   (если   используется   табличное
 выражение, то оно должно иметь метку):

 \   JOIN SYS.сотрудники,SYS.отделы
       WHERE сотрудники.отдел = отделы.отдел
       FOR   сотрудник:сотрудники.фамилия,отдел:отделы.отдел,
             начальник:отделы.начальник

          +-------------+------------+--------------+
          | сотрудник   |   отдел    |   начальник  |
          +-------------+------------+--------------+
          | Иванов      |    3       | Банных       |
          | Абрамович   |    1       | Петренко     |
          | Петров      |    1       | Петренко     |
          | Рабинович   |    2       | Хайкин       |
          | Сидоров     |    2       | Хайкин       |
          | Розенкранц  |    3       | Банных       |
          | Васильев    |    3       | Банных       |
          | Шапиро      |    1       | Петренко     |
          | Гаврилов    |    2       | Хайкин       |
          | Хайкин      |    2       | Хайкин       |
          | Семенов     |    1       | Петренко     |
          | Гурвич      |    3       | Банных       |
          | Владимиров  |    2       | Хайкин       |
          | Петренко    |    1       | Петренко     |
          | Гвоздев     |    1       | Петренко     |
          | Вайлдбрумия |    3       | Банных       |
          | Горгонер    |    2       | Хайкин       |
          | Банных      |    3       | Банных       |
          | Чмухин      |    2       | Хайкин       |
          | Помидорских |    1       | Петренко     |
          | Лигерос     |    1       | Петренко     |
          +-------------+------------+--------------+


 \  JOIN
      S:(GROUP SYS.сотрудники BY отдел
                              FOR отдел,сумма:SUM(зарплата)),
      SYS.отделы
    WHERE отделы.отдел = S.отдел AND S.сумма>отделы.бюджет
    FOR  отдел: S.отдел, начальник: отделы.начальник,
         перерасход: (S.сумма/отделы.бюджет-1)*100

              +--------+-----------+------------+
              | отдел  | начальник | перерасход |
              +--------+-----------+------------+
              |   1    | Петренко  | 17.33333   |
              +--------+-----------+------------+

 \  JOIN
      S:(GROUP SYS.сотрудники BY отдел
                              FOR отдел,сумма:SUM(зарплата)),
      SYS.отделы,
      SYS.сотрудники
    WHERE S.отдел = отделы.отдел AND
          отделы.начальник = сотрудники.фамилия
    FOR отдел: S.отдел, доля: сотрудники.зарплата/S.сумма*100

                      +--------+--------+
                      | отдел  | доля   |
                      +--------+--------+
                      |    1   | 28.409 |
                      |    2   | 21.505 |
                      |    3   | 26.923 |
                      +--------+--------+
\
+            3. Управление структурой базы данных.

   3.1 Создание и уничтожение таблиц

     Для создания  новой  таблицы  служит  операция "CREATE",
 задающая   имя  таблицы,  а  также  имена  столбцов  и  типы
 хранящихся в них данных:

     CREATE TABLE сотрудники
        (фамилия: VARCHAR(20), отдел: short, рождение: short,
         зарплата: float)

     Ключевое слово "TABLE" может быть опущено.

     В  базе  данных  не может быть двух таблиц с одинаковыми
 именами, созданных одним пользователем.
     Для стирания таблицы используется операция "DROP":

     DROP TABLE сотрудники

     DROP TABLE SYS.сотрудники - пользователь с квалификацией
 администратора (см. ниже) может стирать "чужие" таблицы.


 \ 3.2 Индексы

     Помимо   таблиц,  в  базе  данных  могут  использоваться
 "индексы".  Основное назначение индексов - ускорение доступа
 к  данным  (ускорение поиска). Управление индексами сводится
 только  к их созданию и уничтожению, использованием индексов
 управляет система.
     Для      индекса      таблицы     определяется     ключ:
 последовательность  полей-атрибутов  таблицы.  Каждая запись
 индекса  содержит  некоторое  значение  ключа  и список всех
 записей   таблицы,  соответствующих  этому  значению  ключа.
 Записи   хранятся   отсортированными   по   значению   ключа
 (упорядочивание  по убыванию или возрастанию поля, входящего
 в   ключ,   задается   при  создании  индекса).  Эти  записи
 организованы  в  виде т.н. "бинарного дерева", что позволяет
 очень  быстро  найти  в индексе ключ с заданным значением, а
 через него - все записи с соответствующими значениями полей.
     Однако   создание   индексов  приводит  и  к  негативным
 последствиям  - во-первых, требуется дополнительная дисковая
 память   для   хранения   индексов,  а  во-вторых,  скорость
 модификации    таблицы    с    индексами   снижается   из-за
 необходимости модифицировать также и индекс.
     Индексы  создаются  также  для  обеспечения уникальности
 т.н. "первичного ключа". "Первичным ключем" называется такое
 множество атрибутов, что никакие две записи таблицы не могут
 иметь  одинаковый  первичный  ключ.  Для поддержки первичных
 ключей создается "уникальный" индекс (см. ниже)

 \ 3.3 Создание и уничтожение индексов

     Для     создания     индекса    используется    операция
 "CREATE INDEX":

     CREATE INDEX люди ON TABLE SYS.сотрудники (фамилия)

     Ключевое слово "TABLE" может быть опущено.
     В  базе  данных  не  может быть 2 индексов с одинаковыми
 именами, относящихся к одной и той же таблице.
     Можно  образовывать ключи индекса из нескольких столбцов
 таблицы,   при   этом   возможно   упорядочивание   как   по
 возрастанию,так и по убыванию:

     CREATE INDEX хх ON SYS.сотрудники
                                    (отдел ASC,зарплата DESC)

     Возможно  создание  "уникального"  индекса,  т.е. такого
 индекса,  что  каждому  его  ключу соответствует только одна
 запись:

     CREATE UNIQUE INDEX i ON SYS.отделы (отдел)

     При   попытке  вставить   в  таблицу  новую  запись  или
 модифицировать   имеющуюся   так,   что  уникальность  ключа
 нарушится, генерируется сообщение об ошибке.

     Надо заметить, что создание индекса для непустой таблицы
 происходит  не  мгновенно  -  "построение  индекса"  требует
 времени.

     Уничтожение индексов выполняется операцией "DROP INDEX":

     DROP INDEX i  ON TABLE SYS.отделы
     DROP INDEX xx ON SYS.сотрудники

     При уничтожении таблицы автоматически уничтожаются и все
 ее индексы.

\
+                    4. Модификация данных

   4.1 Добавление записей (INSERT)

     Записи   добавляются   в  таблицы  при  помощи  операции
 "INSERT",  которая имеет 2 модификации: "единичный INSERT" и
 "групповой  INSERT".  В  обоих  случаях необходимо указывать
 таблицу  (а  не  табличное выражение), в которую добавляются
 записи.
     "Единичный INSERT" служит для добавления в таблицу одной
 записи. Во  фразе  VALUES  должны  быть  указаны  выражения,
 задающие  значения   для  всех   полей-атрибутов  записи   -
 позиционно и/или  при помощи ключей. При позиционном задании
 значения просто  перечисляются в том порядке, в котором были
 перечислены атрибуты  при создании таблицы операцией CREATE.
 При  позиционном   задании  перед   значением  пишется   имя
 соответствующего  атрибута   (столбца),  отделенное   знаком
 равенства.   Возможно   также   смешанное   задание:  первые
 атрибуты - позиционно, остальные - при помощи ключей:

     INSERT VALUES 'Кривобоков',1,1952,185.00
                                          INTO SYS.сотрудники
     INSERT VALUES отдел=1,фамилия='Кривобоков',
                зарплата=100+85,рождение=1952
                                          INTO SYS.сотрудники
     INSERT VALUES 'Кривобоков',1,
                зарплата=185.00,рождение=1952
                                          INTO SYS.сотрудники

     "Групповой   INSERT"  служит  для  занесения  в  таблицу
 нескольких  (возможно нуля) записей, полученных в результате
 вычисления некоторого табличного выражения. При этом число и
 названия  столбцов  результата  табличного  выражения должны
 соответствовать числу и названию столбцов таблицы, в которую
 производится   вставка   (порядок  столбцов  несущественен).
 Табличное выражение заключается в круглые скобки.

     CREATE TABLE люмпены (фамилия:VARCHAR(20),бюджет:SHORT)

     INSERT (SELECT SYS.сотрудники WHERE зарплата<150
                               FOR бюджет:зарплата,фамилия)
            INTO люмпены

     В  табличном выражении не должна использоваться таблица,
 в которую добавляются записи операцией "групповой INSERT".



 \ 4.2 Удаление записей (DELETE)

     Для  удаления  записей  применяется  операция  "DELETE",
 в  которой  фраза  "WHERE"  определяет  условие для записей,
 подлежащих удалению:

     DELETE SYS.сотрудники WHERE отдел = 1

     В   операции  "DELETE"  должна  использоваться  реальная
 таблица, а не табличное выражение.
     Фраза  WHERE  может  быть  опущена,  тогда удаляются все
 записи  из  таблицы (но, в отличие от операции "DROP TABLE",
 сама таблица остается).
     В  если в предикате фразы "WHERE" используются табличные
 подвыражения,  то  в  них  не должна использоваться таблица,
 из которой удаляются записи операцией "DELETE".



 \ 4.3 Модификация записей

     Для   изменения  значений  отдельных  атрибутов  записей
 служит операция "UPDATE", в которой фраза "WHERE" определяет
 условие  на  записи,  которые  должны быть модифицированы, а
 фраза "SET" определяет новые значения атрибутов, задаваемые,
 как и в операции INSERT - позиционно или при помощи ключей:

   UPDATE SYS.сотрудники WHERE отдел=1
                 SET зарплата = зарплата + 10

   UPDATE SYS.сотрудники WHERE отдел=2
                 SET зарплата = зарплата * 1.2, отдел = 1

     Порядок   атрибутов  во  фразе  SET  несущественен,  при
 вычислении   новых   значений   полей   всегда  используются
 значения, которые были в записи до модификации.
     Фраза    "WHERE"    может    отсутствовать,   при   этом
 модифицируются все записи таблицы.
     В   операции  "UPDATE"  должна  использоваться  реальная
 таблица, а не табличное выражение.
     В если  в предикате  фразы "WHERE", а также в выражениях
 для   новых  значений   атрибутов   используются   табличные
 подвыражения, то  в них  не должна  использоваться  таблица,
 которая модифицируется операцией "UPDATE".


\
+                 5. Параметризация запросов

     Запросы на манипуляцию данными, выдаваемые из прикладных
 программ  пользователя,  могут  быть  "параметризованы": при
 выполнении    запроса   программа   пользователя   указывает
 конкретные значения параметров.
     Параметры  запроса  записываются перед текстом запроса в
 виде  списка,  заключенного в круглые скобки. Каждый элемент
 списка  состоит  из имени параметра и, через двоеточие, типа
 параметра.  В  тексте  запроса  на  значения параметра можно
 сослаться, записав его имя с символом "$" перед ним:

     (a:SHORT,b:FLOAT) SELECT SYS.сотрудники WHERE
          зарплата < $b AND отдел = $a

     (куда:SHORT,просит:FLOAT,кто:VARCHAR(20))
          INSERT VALUES фамилия = $кто, отдел=$куда,
                        рождение= 1956, зарплата =$просит*0.8
          INTO SYS.сотрудники

     (чек:VARCHAR(20),сколько:FLOAT) UPDATE SYS.сотрудники
          WHERE фамилия = $чек
          SET зарплата = зарплата + $сколько

\
+                6. Транзакции и синхронизации

   6.1 Понятие транзакции. Блокировки

     При  модификации базы данных одним из главных требований
 является  поддержание  целостности  хранимых  в  ней данных.
 Нарушиться   целостность   данных   может   из-за   сбоев  и
 мульти-доступа.
     При  сбое   или  останове   программы,  модифицировавшей
 данные, или  сбое всей  системы часть данных может оказаться
 уже модифицированными, а часть - нет.
     Система  управления  базами  данных  является системой с
 мульти-доступом, т.е. одновременно могут выполняться запросы
 нескольких  пользователей,  в  том  числе  и  такие, которые
 используют  общие  таблицы. При модификации данных это может
 привести   к   различным   коллизиям.   Наиболее  характерны
 следующие ситуации:

   1.   "Потерянное   обновление":   возникает   при   чтении
 несколькими  программами  одних  данных  ("одновременно")  и
 последующей  попытке  записать  модифицированный  результат:
 реально  запишутся  только  изменения, сделанные программой,
 выполнявшейся последней.
   2.  "Зависимость  от  незафиксированных  изменений":  одна
 программа модифицировала часть данных, а другая использовала
 эти  частично   модифицированные  данные.   Например,   одна
 программа вычитает  100.00 из  поля "зарплата"  одной записи
 таблицы "сотрудники"  и прибавляет  100.00 к полю "зарплата"
 другой  записи.  В  результате  сумма  "зарплат"  не  должна
 измениться.  Однако,  если  другая  программа  в  это  время
 подсчитывала сумму "зарплат" и прочитала измененное значение
 1-ой записи  и неизмененное  еще значение  2-ой  записи,  то
 сумма окажется на 100.00 меньше реальной.

 \   Для предотвращения указанных коллизий система использует
 принцип  блокировки:   считанные  записи   "блокируются   по
 чтению", модифицированные - "по записи". Точнее, блокируется
 не отдельная  запись, а весь блок таблицы, содержащий данную
 запись.
     Блокировка  по  чтению  называется  также  "совместной",
 "Share"-блокировкой  (S-lock),  т.к.  при  такой  блокировке
 другие  пользователи  базы  данных могут читать данный блок.
 Блокировка   по   записи   называется  также  "монопольной",
 "eXclusive"-блокировкой  (X-lock), т.к. при такой блокировке
 другие пользователи не имеют доступа к данному блоку.

     Если  при  выполнении запросa пользователя потребовалось
 считать   блок,   на   котором  стоит  X-блокировка  другого
 пользователя,  или  потребовалось  модифицировать  блок,  на
 котором  стоит  "чужая"  S-блокировка, то выполнение запроса
 приостанавливается до снятия блокировки.
     Запись  модифицированных блоков производится не на место
 исходных  блоков,  а  в  другие  блоки  диска, поэтому можно
 "восстановить" исходные, немодифицированные значения.

 \   Начало выполнения первого запроса пользователя считается
 началом "транзакции"  (или "логического  элемента  работы").
 Транзакция может  включать выполнение  одного или нескольких
 запросов к  базе данных.  После завершения  транзакции (т.е.
 после того,  как база  данных вновь  приведена программой  в
 целостное   состояние)   программа   должна   "зафиксировать
 изменения".   Все    произведенные   изменения    становятся
 действительными   только    после   "фиксации".   При   этом
 освобождаются  все   блокировки,  сделанные  при  выполнении
 запросов   из   данной   программы.   Все   модифицированные
 программой блоки  дисковой памяти  становятся "исходными", а
 старые "исходные" освобождаются.

 \   В  некоторых  ситуациях (например, обнаружение ошибки во
 входных   данных)   бывает   необходимо   ликвидировать  все
 изменения,  произведенные  с  начала "транзакции". Для этого
 программа может запросить "откатить" транзакцию.

 \   Недостатком   подобного   решения  является  возможность
 возникновения  т.н.   "deadlock"-ов,  т.е.  ситуаций,  когда
 программа "A"  захватила ресурс (например, страницу таблицы)
 "X", а  программа "B"  захватила ресурс "Y"; затем программа
 "A" попыталась  захватить ресурс  "Y", и была приостановлена
 из-за блокировки,  выполненой  программой  "B",  после  чего
 программа  "B"   попыталась  захватить  ресурс  "Y"  и  была
 приостановлена из-за блокировки, выполненной программой "A".
 После  этого   обе  программы   оказываются   во   "взаимной
 блокировке"   и    никогда   не    выйдут    из    состояния
 "приостановленности".
     Система обнаруживает подобные ситуации и откатывает одну
 из  транзакций,  сообщая  об этом соответствующей программе.
 Поэтому  программы  должны  быть  расчитаны на возникновение
 подобных  ситуаций,  либо  повторяя неудавшуюся транзакцию с
 начала, либо используя технику, описанную ниже.

 \ 6.2 Окончание транзакции (COMMIT)

     Для   окончания   транзакции   необходимо   использовать
 операцию   "COMMIT".   При   выполнении  этой  операции  все
 произведенные   пользователем   в  базе  данных  модификации
 "фиксируются", все заблокированные им ресурсы освобождаются:

     COMMIT

 \ 6.3 Откат транзакции (ROLLBACK)

     Для "отката" транзакции необходимо использовать операцию
 "ROLLBACK". При  выполнении этой  операции все произведенные
 пользователем в  базе данных  модификации аннулируются,  все
 заблокированные им ресурсы освобождаются:

     ROLLBACK

     Откат   транзакции   производится   самой  системой  при
 возникновении  ошибочных  ситуаций  определенного  типа (см.
 ниже), а также при перезапуске системы.


 \ 6.4 Блокировка таблиц (LOCK)

     Для   приложений,   требующих   малого  времени  ответа,
 необходимо    избавляться    от    блокировок,   ведущих   к
 приостановкам  в  выполнении  запросов.  Для  этого в начале
 транзакции  можно  сначала  заблокировать все используемые в
 ней  таблицы.  Если  таблица  нужна  только  для  чтения, то
 используется  SHARE - lock, если таблица модифицируется - то
 EXCLUSIVE - lock:

     LOCK TABLE SYS.сотрудники IN SHARE MODE
     LOCK TABLE SYS.отделы     IN EXCLUSIVE MODE

     Ключевое слово "TABLE" может быть опущено

     При  SHARE-блокировке таблицы она остается доступной для
 чтения  остальными пользователями, но запросы на модификацию
 таблицы будут приостановлены сразу же при начале выполнения.
 Если   в   момент   выполнения  операции  LOCK  таблица  уже
 модифицирована  другим пользователем, то выполнение операции
 приостанавливается  до  окончания  транзакции  (транзакций),
 модифицировавших эту таблицу.

     При    EXCLUSIVE-блокировке   приостанавливается   любой
 запрос  другого  пользователя,  использующий данную таблицу.
 Если  в  момент  выполнения  операции  LOCK таблица уже была
 использована  другим  пользователем,  то выполнение операции
 приостанавливается  до  окончания  транзакции  (транзакций),
 использовавших эту таблицу.

     Блокировка   таблиц   может  избавить  от  необходимости
 сохранять  исходные  данные  вне базы для повтора транзакции
 после  "deadlock"-а.  Если  в  начале  транзакции  выполнять
 необходимые   блокировки   таблиц,   то  "deadlock"-и  могут
 появляться  во  время  захватов  таблиц, когда процесс легко
 повторить, но  не во время выполнения запросов, использующих
 входные данные.

\
+                   7. Скалярные выражения.

     Выражения,  определяющие  предикаты  и проекции, а также
 новые  значения  в  операторах  INSERT  и UPDATE, называются
 "скалярными    выражениями"   (в   отличие   от   "табличных
 выражений"),  так  как  они  оперируют  с единичными данными
 (скалярами),  а  не  с  таблицами,  и  в качестве результата
 выдают    единичное   данное   (скаляр).   Такие   выражения
 соответствуют   обычным   выражениям   традиционных   языков
 программирования.
     Скалярное  выражение  строится  из  скалярных операндов,
 связанных скалярными операциями, и скалярных функций.

   7.1 Скалярные операнды

     Операндом скалярного выражения могут быть:

 а)  поля-атрибуты  текущей  записи (записей - для JOIN); они
 обозначаются  просто  именем  атрибута (столбца), возможно с
 префиксом-квалификатором,     указывающим    на    табличное
 выражение, к которому относится атрибут.

 б)  константы, которые записываются следующим образом:
 SHORT,  LONG  - последовательность цифр без десятичной точки
 (тип выбирается в зависимости от значения числа):
     20     ,  10000                  - SHORT
     40000  ,  12345789               - LONG
 FLOAT  -  последовательность  цифр с точкой и/или десятичным
 множителем,  который  записывается  в  виде  буквы  "E",  за
 которой  следует  величина десятичного порядка (возможно, со
 знаком):
     20.02 , 0.12345, 12E07, 13.45E-53, 0.1234E+9
 CHAR    -   последовательность   символов,   заключенная   в
 апострофы или в кавычки:
    'ABC' , 'Тестовая строка', "Это 'строка с апострофами'"

 в) функции редукции (см. выше)
     MIN(<скалярное выражение>),  MAX(<скалярное выражение>),
     SUM(<скалярное выражение>),  AVG(<скалярное выражение>),
     COUNT(*)
 функции  SUM  и  AVG  определены  только  для числовых типов
 данных;   тип   функции  совпадает  с  типом  аргумента,  за
 исключением  функций  SUM  и AVG от аргумента типа "SHORT" -
 значение в этом случае имеет тип "LONG"; тип функции COUNT -
 "LONG";

 г)   параметры  запроса,  которые  записываются  при  помощи
 символа "$" со следующим за ним именем параметра:
     (год:SHORT,лимит:FLOAT) SELECT SYS.сотрудники
               WHERE рождение >= $год AND зарплата > $лимит

 д) операции явного преобразования типа, которые записываются
 как  функции  с  именами,  соответствующими именам требуемых
 типов:
     LONG (15.78E07)  -> 157800000
     SHORT(15.78E01)  -> 157
     FLOAT(12300000)  -> 1.23E07
 функции преобразования в числовые типы определены только для
 числовых типов аргументов, причем при преобразовании из типа
 FLOAT в  типы LONG  и SHORT дробная часть отбрасывается (без
 округления);
     функции преобразования текстовых типов определены только
 для аргумента текстового типа; они имеют также 2-ой аргумент
 -  длину  строки  (для VARCHAR - максимальную длину строки),
 задаваемую числовой константой:
     CHAR('AAAA',10)  -> 'AAAA      '
     VARCHAR('AAAA    ',20)  -> 'AAAA'

 е) обращения к встроенным скалярным функциям:
     TIME(), YEAR(..) и т.п.

 ж) подзапросы

 \ 7.2 Скалярные операции

     К  скалярным операциям относятся арифметические операции
 (которые применимы только к данным числовых типов):
 +   -  сложить,           -   -  вычесть,
 *   -  умножить,          /   -  разделить,
 MOD -  взять остаток,

     а также операции сравнения:
 =   -  равно,             =/= -  не равно,
 >   -  больше,            >=  -  больше или равно
 <   -  меньше,            <=  -  меньше или равно
 LIKE-  сравнить с образцом

     При  выполнении   арифметических  операций  с  числовыми
 данными  разного типа операнды приводятся к "старшему" типу,
 старшинство  типов  (по  возрастанию):  SHORT,  LONG, FLOAT.
 Операция MOD неопределена для аргументов типа FLOAT.

     Данные  типов  CHAR  и  VARCHAR  различной  длины  могут
 произвольно  смешиваться  в  выражениях,  при  этом  меньшая
 строка дополняется справа пробелами до длины большей.

     При  выполнении  арифметических  операций тип результата
 совпадает  с типами операндов (после приведения к "старшему"
 типу в случае смешения типов).

     При занесении  данных  в  таблицы  операциями  INSERT  и
 UPDATE тип  выражения  приводится  к  типу  соответствующего
 атрибута  (столбца).   При  преобразовании   строки  к  типу
 фиксированной  строки  (CHAR)  с  длиной,  большей  текущей,
 происходит   дополнение   строки   справа   пробелами;   при
 преобразовании к типу фиксированной строки с длиной, меньшей
 текущей -  усечка концевых  символов, причем  если среди них
 есть  символ,  отличный  от  пробела,  то  возникает  ошибка
 "переполнение".  При  присваивании  значения  атрибуту  типа
 "строка переменной  длины" (VARCHAR)  усекаются все концевые
 пробелы,  а   если  получившаяся   строка  все   же   длинее
 максимальной  длины,   заданной  для  данного  атрибута,  то
 фиксируется ошибка "переполнение".

 \   Операция  LIKE  действительна  для 2 текстовых операндов
 и сравнивает первый операнд со вторым, являющимся 'образцом'
 сравнения. Образец может содержать т.н. "спец-символы":
  !  - соответствует любому символу строки
  ?  - соттветствует любой подстроке (в т.ч. пустой)
  _  - соответствует любой послед-ти пробелов (в т.ч. пустой)
  [  - начало альтернативы: последовательность символов между
       "[" и "]" задает множество допустимых символов.
 Остальные (не "спец") символы соответствуют сами себе.

     Примеры:
 Образец    Подходящие под образец строки
 --------  -------------------------------
 'Стул'     'Стул' (и никакие другие)
 'Ст[оу]л'  'Стол',  'Стул' (и никакие другие)
 'Ст!л'     'Стул',  'Стол' и т.п.
 'Ст?л'     'Стул',  'Стол', 'Стл', 'Стамбул', ...
 '?т?л'     'Стул',  'Стол', 'Стл', 'Стамбул', 'этил',...
 'else_if'  'elseif','else if', 'else  if', ...

 Замечание: число спец-символов типа "?" и "_" ограничено (не
 более   20),   при  большем  количестве  выдается  сообщение
 "Переполнение".

 \ 7.3 Скалярные функции

     Скалярные функции  выдают в качестве результата 1 данное
 (скаляр).   У  таких  функций  возможны  аргументы,  которые
 записываются  в  круглых скобках (через запятую) после имени
 функции. Если функция не имеет аргументов, то после ее имени
 все равно пишется пара круглых скобок.

 \   Функция   Тип      Параметры      Значение результата
    --------- ----- --------------- ------------------------
     TIME     long        нет       номер минуты от полуночи
                                    1 января 1900 года
                                    (т.н. системный формат)
     YEAR     short   время в сист. номер соответствующего
                        формате     года в этом веке
     MONTH    short   время в сист. номер соответствующего
                        формате     месяца (1 - январь)
     DAY      short   время в сист. номер соответствующего
                        формате     дня месяца
     WEEKDAY  short   время в сист. номер соответствующего
                        формате     дня недели:1-понедельник
     MINUTE   short   время в сист. номер соответствующей
                        формате     минуты по полуночи
     USER     short       нет       внутренний идентификатор
                                    пользователя

 Примеры:
     YEAR(TIME())        90     - текущий год
     MINUTE(TIME())      212    - текущая минута пополуночи
     TIME() MOD (60*24)  212    - текущая минута пополуночи
     Select &CATALOG where OWNER=USER() for NAME;


 \ 7.4 Условные выражения

     Условным   выражением   называется   конструкция   вида:
   IF <условие> THEN <t-выражение> ELSE <f-выражение>
 где  в  зависимости от истинности <условия> вычисляется либо
 <t-выражение>  (при  выполнении условия), либо <f-выражение>
 (при  невыполнении  условия).  Конструкция  может  содержать
 более одного условия:
    IF <условие-1> THEN <t1-выражение>
       ELSE IF <условие-2> THEN <t2-выражение>
       ELSE IF <условие-3> THEN <t3-выражение>
       ....
       ELSE <f-выражение>

 где выполнение <условия-n> влечет вычисление <tn-выражения>,
 а   невыполнение   -   проверку   следующего   условия;  при
 невыполнении всех условий вычисляется <f-выражение>.
     Если типы <tn,f-выражений> различны, то они приводятся к
 "старшему"  по  тем  же  правилам,  что  и операнды бинарных
 операций.
     Select сотрудники for фамилия,
              кто:(if отдел=1 then 'охотник' else 'дичь')


 \ 7.5 Подзапросы

     Подзапросом  является  предикат или скалярное выражение,
 получаемое из некоторого табличного выражения.


     Подзапрос-предикат записывается в виде:

 EXISTS (<табличное выражение>)

 и   выдает  значение:
     "истина",  если  результат табличного выражения содержит
                как минимум 1 строку,
     "ложь",    если результатом является пустая таблица


    Подзапрос-выражение записывается в виде:

 (<табличное выражение>)

 при  этом  результат  табличного  выражения  должен  иметь 1
 столбец  и ровно 1 строку, т.е. результат должен состоять из
 1    значения,    которое    и   принимается   за   значение
 "подзапроса-выражения".

    В  теле  подзапроса  допустимы  ссылки  не только на поля
 таблиц,  участвующих  в  подзапросе,  но и на поля табличных
 выражений,  используемых  в  табличном выражении, включающем
 подзапрос.

    Пример:
 SELECT SYS.сотрудники
 FOR фамилия,
     кто:IF EXISTS(SELECT SYS.отделы
                WHERE начальник=сотрудники.фамилия)
         THEN 'начальник' ELSE 'работник'

 SELECT SYS.сотрудники
 FOR фамилия,
     доля:зарплата/(SELECT SYS.отделы
                    WHERE  отдел=сотрудники.отдел
                    FOR    бюджет)

\
+                   8. Авторизация доступа

   8.1 Принципы идентификации

     Система    управления   базами   данных   расчитана   на
 коллективное  использование,  поэтому  она содержит механизм
 для  определения и проверки прав пользователей на выполнение
 определенных   операций   над  хранимыми  данными  (механизм
 авторизации).
     Для  поддержки  авторизации  в  базе  данных  существует
 список имен пользователей, могущих работать с базой, который
 содержит также их пароли и "привилегии".
     В  начале  сеанса пользователь должен выполнить операцию
 идентификации "LOGON", указав свое имя и пароль:

     LOGON OPERATOR КваКа

     Если   имя   пользователя  найдено  в  списке  и  пароль
 совпадает    с    указанным,   то   пользователь   считается
 "идентифицированым"   и   может  выполнять  разрешенные  ему
 операции.
     Если  идентификация  не произведена, то пользователь все
 же  может работать с базой данных, но может выполнять только
 те операции, которые разрешены "всем" (см. ниже).
     ЗАМЕЧАНИЕ.   Два  одновременно  работающих  пользователя
 могут  идентифицироваться  под одним именем, но это никак не
 повлияет  на  описанный выше механизм транзакций - каждый из
 них выполняет "свои" транзакции. Идентификация служит только
 для проверки прав пользователя.
     После  идентификации  обращение к "собственным" таблицам
 пользователя  не  требует  добаления  имени  владельца перед
 именем таблицы:
     SELECT SYS.сотрудники FOR фамилия;
     LOGON  SYS пароль;
     SELECT сотрудники     FOR фамилия; \ оба варианта
     SELECT SYS.сотрудники FOR фамилия; / допустимы


 \ 8.2 Права пользователя

     За  каждым  занесенным в список пользователем закреплены
 определенные "привилегии". Такими привилегиями являются:
     ADMIN  -  "администратор";  пользователь,  имеющий такую
 "привилегию"   имеет   право   выполнить   любую   операцию,
 поддерживаемую СУБД.
     OPER   -   "оператор";   пользователь,   имеющий   такую
 "привилегию",  имеет  право  выполнять операции, связанные с
 управлением СУБД: архивацию, останов и т.п.
     CREATE   -   "создатель";  пользователь,  имеющий  такую
 "привилегию",  имеет  право  создавать  в  базе данных новые
 таблицы.

     Если  пользователь  не  "идентифицировался" (не выполнил
 операцию LOGON), то он не обладает ни одной из перечисленных
 привилегий.

     Управление     "привилегиями"     выполняется     только
 пользователем-администратором  при  помощи  операций GRANT и
 REVOKE.
     Занесение пользователя  в список производится при помощи
 операции "GRANT CONNECT" с указанием имени пользователя и (в
 скобках) его пароля:

     GRANT CONNECT TO OPERATOR (КваКа)

 При помощи этой операции можно поменять пароль пользователя.

     Исключение пользователя производится при помощи операции
 "REVOKE CONNECT":

     REVOKE CONNECT FROM OPERATOR

     Привилегии  даются  пользователям  и  отбираются  у  них
 аналогичными операциями:

     GRANT OPER TO OPERATOR

     REVOKE CREATE FROM IVANOV


 \ 8.3 Доступ к таблицам

     После   создания   таблицы  выбирать  из  нее  данные  и
 модифицировать  таблицу  может  только ее создатель, а также
 пользователи,  имеющие  привилегию  "ADMIN". Для того, чтобы
 предоставить  другим  пользователям  возможность  работать с
 таблицей, они должны разрешить им доступ при помощи операции
 GRANT  с  указанием  списка  разрешаемых  операций  (чтение,
 модификация, вставка,  удаление) и  имени таблицы,  а  также
 имени пользователя:

     GRANT READ SYS.сотрудники TO IVANOV

     GRANT UPDATE, INSERT TABLE SYS.сотрудники TO ОСОБИСТ

     GRANT DELETE SYS.сотрудники TO DIRECTOR

     Чтобы  разрешить  все возможные операции манипулирования
 данными, можно использовать следующую форму:

     GRANT ALL ON рабочая TO STUDENT

     Вместо  имени  пользователя  можно указать "PUBLIC", что
 означает   "всем",  в  том  числе  и  не  идентифицированным
 пользователям:

     GRANT READ SYS.отделы TO PUBLIC

     Предоставление  какого-либо права на модификацию таблицы
 автоматически предоставляет право на выборку из нее (READ).

     Лишение  прав  доступа  производится при помощи операции
 "REVOKE":

     REVOKE ALL ON SYS.сотрудники FROM ОСОБИСТ

     REVOKE UPDATE SYS.сотрудники FROM DIRECTOR

     REVOKE READ   SYS.отделы     FROM PUBLIC

     Лишение права на чтение таблицы автоматически приводит к
 лишению всех прав на модификацию (эквивалентно REVOKE ALL).
     Заметим,  что  в  первом  случае  из  последнего примера
 пользователь  ОСОБИСТ  потерял право доступа к таблице, а во
 втором  -  пользователь  DIRECTOR  сохранил  право на чтение
 таблицы.
     Лишение прав доступа с указанием "PUBLIC" не лишает прав
 доступа   пользователей,   для   которых   это   право  было
 предоставлено  отдельной   командой   GRANT  (т.е.  и  после
 выполнения    третьей   операции   из   последнего   примера
 пользователь   DIRECTOR   сохранит   свое  право  на  чтение
 таблицы).
     Уничтожать  таблицу может только пользователь, создавший
 ее, или имеющий привилегию ADMIN.
     Для   совместной   блокировки   таблицы   (SHARE   MODE)
 пользователь  должен иметь право на чтение этой таблицы, для
 монопольной блокировки - хотя бы одно из прав на модификацию
 таблицы.
     Для  создания  индекса таблицы пользователь обязан иметь
 привилегию  ADMIN, или он должен иметь привилегию "CREATE" и
 быть владельцем таблицы.

     Операции   над  правами  доступа  выполняются  в  рамках
 транзакции  и,  следовательно, могут быть или зафиксированы,
 или "откатаны".
\
+                   9. Специальные запросы

     Вместо  имени  таблицы в операциях выборки можно указать
 "&CATALOG"  -  эта  фиктивная таблица - каталог базы данных.
 Она имеет следующие столбцы:

 имя столбца      тип         значение
 ------------  ------------  --------------------------------
 NAME           VARCHAR(20)   имя таблицы или индекса
 OWNER          SHORT         идентификатор владельца
 TYPE           CHAR(1)       'T' - таблица, 'I' - индекс
 NRECORDS       LONG          число записей/число ключей
 SIZE           LONG          размер таблицы/индекса в блоках
 TABLENAME      VARCHAR(20)   для  индекса  - имя таблицы,  к
                              которой   он   относится,   для
                              таблицы - пустая строка

     Вместо имени  таблицы в  операциях выборки можно указать
 "&USERS" - эта фиктивная таблица - список зарегистрированных
 пользователей базы данных. Она имеет следующие столбцы:

 имя столбца      тип         значение
 ------------  ------------  --------------------------------
 USERID         SHORT         идентификатор пользователя
 NAME           VARCHAR(10)   имя пользователя
 ADMIN          CHAR(1)       флаг квалификации "ADMIN"
 CREATE         CHAR(1)       флаг квалификации "CREATE"
 OPER           CHAR(1)       флаг квалификации "OPER"
 PASSWORD       CHAR(8)       пароль пользователя
   последний   столбец   доступен   только   пользователю   с
 квалификацией "ADMIN".  Здесь и далее поля - флаги принимают
 значение "*" в случае истинности, иначе они содержат пробел.


     Вместо  имени  таблицы  в  операциях  выборки может быть
 также  указана  конструкция вида: &COLUMNS(имя таблицы). Эта
 фиктивная   таблица  содержит  описания  столбцов  указанной
 таблицы:

 имя столбца      тип         значение
 ------------  ------------  --------------------------------
 NAME           VARCHAR(30)   имя столбца таблицы
 TYPE           CHAR(1)       тип данных: 'S'-SHORT,'L'-LONG
                              'F'-FLOAT,'C'-CHAR,'V'-VARCHAR
 LENGTH         SHORT         длина данных (для VARCHAR- max)


     Вместо  имени  таблицы  в  операциях  выборки может быть
 также  указана  конструкция  вида: &ACCESS(имя таблицы). Эта
 фиктивная таблица содержит описания прав доступа к указанной
 таблице:

 имя столбца      тип         значение
 ------------  ------------  --------------------------------
 USERID         SHORT        идентификатор пользователя
 READ           CHAR(1)      флаг разрешения чтения таблицы
 UPDATE         CHAR(1)      флаг разрешения модификации
 INSERT         CHAR(1)      флаг разрешения вставки записей
 DELETE         CHAR(1)      флаг разрешения удаления записей

 если  USERID  = -1, то данная запись описывает права доступа
 к таблице, разрешенные всем (GRANT ... TO PUBLIC).

\
    При необходимости текст запроса может начинаться со слова
 COMPILE  -  это  явно  указывает  на то, что запрос является
 запросом на манипулирование данными (это слово пишется перед
 списком параметров, если они есть).

    Указание ключевого слова "READ" перед текстом запроса (но
 после   списка  параметров)  указывает  на  то,  что  запрос
 является запросом на выборку (чтение) данных.
\
+           10. Формальное описание языка запросов

  запрос ::=           немедленный_запрос      |
                       интерпретируемый_запрос |
             [COMPILE] компилируемый_запрос

  немедленный_запрос ::= COMMIT | ROLLBACK

  интерпретируемый_запрос ::=
    CREATE [TABLE] имя_таблицы
      (описание_колонки [, описание_колонки ...])           |
    CREATE [UNIQUE] INDEX имя_индекса
      ON [TABLE] имя_таблицы (список_упорядочивания)        |
    DROP TABLE имя_таблицы                                  |
    DROP INDEX имя_индекса ON [TABLE] имя_таблицы           |
    LOCK [TABLE]  имя_таблицы IN вид_блокировки MODE        |
    GRANT  CONNECT            TO имя_пользователя(пароль)   |
    GRANT  права_пользователя TO имя_пользователя           |
    REVOKE CONNECT            FROM имя_пользователя         |
    REVOKE права_пользователя FROM имя_пользователя         |
    GRANT  права_доступа [TABLE] имя_таблицы TO   автор-ый  |
    REVOKE права_доступа [TABLE] имя_таблицы FROM автор-ый

  описание_колонки  ::= имя_колонки : описание_типа

  описание_типа     ::= числовой_тип         |
                        текстовый_тип(длина)

  числовой_тип      ::= SHORT  | LONG | FLOAT
  текстовый_тип     ::= CHAR   | VARCHAR

  вид_блокировки    ::= SHARE  | EXCLUSIVE

  права_пользователя::= ADMIN  | OPER   | CREATE

  права_доступа     ::= READ   | INSERT | DELETE |
                        UPDATE | ALL ON

  автор-ый          ::= PUBLIC | имя_пользователя


 \
  компилируемый_запрос  ::=
    [ (параметр_запроса [, параметр_запроса ...]) манипуляция

  параметр запроса  ::= описание_колонки

  манипуляция ::=
     [READ] выборка                                        |
     DELETE [FROM] имя_таблицы [WHERE предикат]            |
     UPDATE имя_таблицы [WHERE предикат]
                SET список_данных                          |
     INSERT (выборка) INTO имя_таблицы                     |
     INSERT VALUES список_данных INTO имя_таблицы

  список_данных       ::= список_значений |
                     [список_значений ,] список_присваиваний
  список_значений     ::= выражение [,список значений ]
  список_присваиваний ::= присваивание [,список_присваиваний]
  присваивание        ::= имя_столбца = выражение

  выборка ::= операция_выборки [FOR проекция [, проекция...]]

  проекция ::= имя_столбца |
               имя_столбца : выражение

  операция_выборки ::=
    SELECT табличное [WHERE предикат]                       |
    JOIN   табличное,табличное[,табличное.] [WHERE условие] |
    ORDER  табличное BY список_упорядочивания               |
    GROUP  табличное BY столбец [, столбец ...]             |
    UNION  табличное,табличное [, табличное ...]

  табличное  ::= [метка :] ( выборка ) |
                 [метка :] имя_таблицы |
                 [метка :] & спец_запрос

  спец_запрос::= CATALOG              | USERS               |
                 COLUMNS(имя_таблицы) | ACCESS(имя_таблицы)

  список_упорядочивания ::=
            элемент_упорядочивания [, список_упорядочивания]
  элемент_упорядочивания ::= имя_столбца [ ASC | DESC]
 \
  предикат   ::= предикат-a | предикат-a OR  предикат
  предикат-a ::= предикат-m | предикат-m AND предикат-a
  предикат-m ::= предикат-u | NOT предикат-u
  предикат-u ::= выражение операция_отношения выражение |
                 подзапрос_предикат | ( предикат )

  операция_отношения ::= > | >= | < | <= | = | =/=

  подзапрос-предикат ::= EXISTS ( операция_выборки )

  выражение   ::= выражение-a |
                  выражение-a аддитивная выражение
  выражение-a ::= выражение-m |
                  выражение-m мультипликативная выражение-m
  выражение-m ::= выражение-u | аддитивная выражение-u

  выражение-u ::= проекция          | $имя_параметра      |
                  float_константа   | fixed_константа     |
                  char_константа    | редукция            |
                  скалярная         | преобразование типа |
                  условное_выражение| подзапрос_выражение |
                  ( выражение )

  аддитивная        ::= + | -
  мультипликативная ::= * | / | MOD

  проекция          ::= имя_столбца                  |
                        имя_подвыражения.имя_столбца
  имя_подвыражения  ::= имя_метки | имя_таблицы

  редукция          ::= функция_редукции(выражение) |
                        COUNT(*)
  функция_редукции  ::= SUM | AVG | MIN | MAX

  преобразование_типа ::= числовой_тип ( выражение ) |
                          текстовый_тип( выражение, длина)

  скалярная           ::= скалярная функция
                          ( [ список_значений] )

  скалярная_функция   ::= USER | TIME | MINUTE |
                          YEAR | MONTH | DAY | WEEKDAY

  условное_выражение  ::= IF <предикат> THEN <выражение>
                                        ELSE <выражение>
  подзапрос_выражение ::= ( операция_выборки )

 \
  fixed_константа     ::= цифра [цифра ...]
  float_константа     ::= fixed_константа . [fixed_константа]
                          [ E [аддитивная] fixed_константа]

  char_константа  ::= 'char_тело-1' | "char-тело-2"
  char_тело-1     ::= от 0 до 400 символов кроме "'"
  char_тело-2     ::= от 0 до 400 символов кроме '"'

  цифра           ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9


  имя_таблицы       ::= имя_пользователя . таб_имя | таб_имя
  метка             ::= имя(20)
  таб_имя           ::= имя(20)
  имя_столбца       ::= имя(30)
  имя_параметра     ::= имя(30)
  имя_пользователя  ::= имя(10)
  пароль            ::= имя(8)

  имя(n)  ::=  последовательность  букв,  цифр  и  знаков "_"
               длиной не более  "n",  начинающаяся не с цифры
